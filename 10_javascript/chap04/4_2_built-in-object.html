<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    // 2. 내장 객체(js 기본 제공)
    // 자바스크립트 엔진에 내장되어 필요한 경우 생성하여 사용

    // 1) 날짜 정보 객체: 날짜와 시간에 대한 정보를 제공
    // 변수 = new Date();
    // 사용서어이 떨어져서 다른 외부 라이브러리 사용을 추천


    // 오늘 날짜에 대한 정보를 가지고 있는 객체 생성
    const today = new Date();
    const nowYear = today.getFullYear();
    const nowMonth = today.getMonth();
    const nowDate = today.getDate();
    const nowDay = today.getDay();

    document.write('<h1>오늘 날짜 정보</h1>');
    document.write(`현재 연도:${nowYear}<br>`);
    document.write(`현재 월:${nowMonth}<br>`);
    document.write(`현재 일:${nowDate}<br>`);
    document.write(`현재 요일:${nowDay}<br>`);

      // 특정 날짜 정보를 갖는 날짜 객체 생성
      // New Date(연, 월, 일, 시, 분 ,초 밀리초);
      // 변수 = new Date (연, 월-1(0~11) ,일);
      // 변수 = new Date('2023/12/31');
      // 변수 = new Date('2023-12-31');
    const someDay = new Date(2023, 11, 31);
    const theYear = someDay.getFullYear();
    const theMonth = someDay.getMonth();//현재 월보다 1낮게 나옴
    const theDate = someDay.getDate();
    const theDay = someDay.getDay(); // 0~6: 일~토

    document.write('<h1>특정 날짜 정보</h1>');
    document.write(`특정 연도:${theYear}<br>`);
    document.write(`특정 월:${theMonth}<br>`);
    document.write(`특정 일:${theDate}<br>`);
    document.write(`특정 요일:${theDay}<br>`);

    //특정 날짜까지 D-day 구하기
    //남은 일 수 = 특정 날짜 객체 시간 -현재 날짜 객체 시간
    //1초 = 1000ms
    //1분(60초) = 1000 - 60
    //1시간 (60분) = 1000 * 60 * 60
    //1일(24시간) = 1000 * 60 * 60 * 24 

    const classEndDate = new Date(2023, 2 ,10);
    const diffDate = classEndDate.getTime() - new Date().getTime();
    //getTime():1970년 1월 1일 0시 0분 0초로부터 지금까지 몇 ms가 지났는지

    const result = Math.ceil(diffDate / (1000*60*60*24));
    document.write('<h1>오늘부터 종강까지 남은 날짜</h1>');
    document.write(`D-day:${result}일 남았습니다.`);

    //2) 수학 객체: 수학 관련 기능과 속성을 제공
    //객체 생성을 하지 않고 사용 가능 -> 정적(static) 객체
    // Math.메소드명();
    // Math.속성명;
    document.write('<h1>수학 객체 사용</h1>');
    const num = 2.1234;
    const maxNum = Math.max(10, 5, 8, 30); //최대값
    document.write(maxNum, '<br>')
    const minNum = Math.min(10, 5, 8, 30); //최대값
    document.write(minNum, '<br>')

    const roundNum = Math.round(num); // 소수 첫재짜리 반올림
    const floorNum = Math.floor(num); // 소수 첫재짜리 내림
    const ceilNum = Math.ceil(num); // 소수 첫재짜리 올림
    document.write(roundNum, '<br>');
    document.write(floorNum, '<br>');
    document.write(ceilNum, '<br>');


    const randomNum = Math.random();// 0이상 1미만의 난수 발생(실수값)
    document.write(randomNum, '<br>');


    document.write(Math.PI, '<br>');

    // random()을 이용하여 특정 범위의 랜덤한 정수값 구하기

    document.write('<h1>특정 범위의 랜덤한 정수 값 구하기 사용</h1>');
    // Math.random() 0이상 1미만의 랜덤한 실수값
    document.write(randomNum, '<br>');

    // Math.random()*10 0이상 10미만의 랜덤한 실수값
    document.write(randomNum*10, '<br>');

    // Math.floor(Math.random()*10)-소수점 버림 0이상 10미만의 랜덤한 정수값 0~9까지 랜덤한 정수값
    document.write(Math.floor(Math.random()*10), '<br>');


    // Math.floor(Math.random()*10)+1 1이상 11미만의 랜덤한 정수값 1~10까지 
    document.write(Math.floor(Math.random()*10)+1, '<br>');

    // 컴퓨터가 내려는 가위, 바위, 보 맞추기!
    document.write('<h1>컴퓨터 가위, 바위, 보 맞추기!</h1>');
    const game = prompt('가위, 바위, 보 중 선택하세요.', '가위');

    let gameNum;

    switch (game) {
      case '가위':
          gameNum = 1;
        break;
      case '바위':
          gameNum = 2;
        break;
      case '보':
          gameNum = 3;
        break;
    
      default:
        alert('잘못 입력하셨습니다.');
        location.reload();
        break;
    }

    //1~3사이의 난수발생

    const com = Math.floor(Math.random()*3)+1;
    // document.write('<img scr = "images/math_img_' + com + '.jpg">');
    document.write(`<img src="images/math_img_${com}.jpg">`);

    if(com === gameNum){
      document.write(`<img src = "images/game_1.jpg">`);

    }else{
      document.write(`<img src = "images/game_2.jpg">`);

    }
    document.write('<br>');

    //  3) 배열 객체: 변수에는 하나의 데이터만 저장 가능, 배열에는 여러 개의 데이터를 순차적으로 하나의 저장소에 저장
    //  예: 학생 30명의 시험 점수를 저장하려면 30개의 변수가 필요한데, 배열을 이용하면 하나의 배열로 30개의 데이터 저장 가능

    // 배열 객체 생성 3가지 방식
    // 첫번재 방식
    // 변수 = new Array(값1, 값2, 값3);

    // 두번째 방식
    // 변수 = new Array();
    // 변수[0] = 값1;
    // 변수[1] = 값2;
    // 변수[2] = 값3;


    // 세번째 방식
    // 변수 = [값1, 값2, 값3]; => 리터널 방식

    // 배열에 접근하기
    // 배열의 인덱스는 0부터 시작
    // 변수[인덱스 번호]로 접근 가능

    // 배열에 저장된 값 출력하기(여러가지 방법 존재)
    const arr = [30, '따르릉', true];
    
    document.write('<h3>배열값 가져오기-1</h3>');
    document.write(arr[0],'<br>');
    document.write(arr[1],'<br>');
    document.write(arr[2],'<br>');

    document.write('<h3>배열값 가져오기-2</h3>');
    for(i = 0; i < arr.length; i++){
      document.write(arr[i], '<br>');
    }
    document.write('<h3>배열값 가져오기-3</h3>');
    for (const i in arr) {
      document.write(arr[i], '<br>');

    }
    //(참고)for in 반복문은 배열이 아니라 객체에 사용할 때 최적화 되어 있어서 배열에 사용하면 객체대비 10~100배 느림
    // 배열에 사용하는것을 지양


    document.write('<h3>배열값 가져오기-4</h3>');
    for (const el of arr) { // ES6차 문법
      document.write(el, '<br>');
      
    }
    document.write('<h3>배열값 가져오기-5</h3>');
    arr.forEach(function(el, index){
      document.write(index, '', el, '<br>');
    });

    // 배열 객체의 메소드(1)
    const arr1 = ['사당', '교대', '방배', '강남'];
    const arr2 = ['신사', '압구정', '옥수'];

    let resulrArr = arr1.join('-'); // 배열의 값을 지정한 문자로 연결하여 하나의 문자열로 반환
    console.log(resulrArr);

    resulrArr = arr1.concat(arr2); // 2개의 배열을 하나의 배열로 결합하여 새로운 배열로 반환
    console.log(resultArr);

    resultArr = arr1.slice(1, 3); // 지정된 시작과 끝 위치 구간만큼 잘라내서 새로운 배열로 반환
    console.log(resultArr);


    arr1.sort(); // 배열의 값을 오름차순(알파벳 순)으로 정렬 원본 배열이 변경됨
    console.log(arr1);


    arr2.reverse(); // 배열의순서를 반대로 바꿈 (원본 배열이 변경됨)
    console.log(arr2);


    // 배열 객체의 메소드(2)
    
    const greenArr = ['교대', '방배', '강남'];
    const yellowArr = ['미금', '정자', '수서'];
    //splice(index, 갯수(howmany), items...)
    greenArr.splice(2, 1, '서초', '역삼'); // 배열 요소를 추가하거나 제거 (2,1 몇부터 몇개를 제거할까요? 2 부터 1개 제거)(원본 배열 변경됨)
    console.log(greenArr);



    const popData = yellowArr.pop(); // 마지막 요소를 제거 제거된 요소를 반환(시프트는 맨 앞에 제거) 원본 배열 변경됨
    console.log(popData);
    const shiftData = yellowArr.pop(); // 첫번째 요소를 제거 제거된 요소를 반환 원본 배열 변경됨
    console.log(shiftData);

    // 배열 객체의 메소드(3) - 검색

    const fruits = ['Banana', 'Orange', 'Apple', 'Mango', 'Apple'];

    // indexof(): 지정된 값의 첫번째 인덱스 (위치)를 반환, 찾을 수 없는 경우 -1
    let index = fruits.indexOf('Apple'); // 첫번째 값을 찾으면 종료
    console.log(index);
    index = fruits.indexOf('Apple', 3); // 검색 시작 위치 지정
    console.log(index);
    // includes(): 지정된 값이 포함된 경우 ture, 포함되지 않은 경우 false (ES7차)
    console.log(fruits.includes('Mango'));
    console.log(fruits.includes('Banana', 3));//검색 시작 위치 지정 


  </script>
</head>
<body>
  <h1>오늘부터 특정일까지 남은 실시간 시간</h1>
  <h2 class="d-day-count"></h2>
  
  <script>
    // (응용) D-day를 '일 시간 분 초'로 실시간 표시하기
    const tomorrow = new Date(2023, 0, 7);
    const dDayCountEl = document.querySelector('.d-day-count');

    function counter(){
    const diff = tomorrow.getTime() - new Date().getTime();
    // document.write(diff, '밀리초<br>');

    // document.write(diff / (1000 * 60 * 60 * 24), '일<br>');

    const dDay = Math.floor(diff / (1000 * 60 * 60 * 24),);
    
    // document.write(diff / ((1000 * 60 * 60)) % 24, '시간<br>');
    const dHour = Math.floor(diff / ((1000 * 60 * 60)) % 24);

    // document.write(diff / ((1000 * 60)) % 60, '분<br>');
    const dMin = Math.floor(diff / ((1000 * 60)) % 60);

    // document.write(diff / ((1000)) % 60, '초<br>');
    const dSec = Math.floor(diff / ((1000)) % 60);


    dDayCountEl.textContent = `${dDay}일 ${dHour}시간 ${dMin}분 ${dSec}초 남음`;
    }
    setInterval(counter,1000);
  </script>
</body>
</html>